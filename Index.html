<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sølvmagisk Cirkel med Dynamiske Symbol-Tentakler</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, magicCircle, particles;
        let isActivated = false;
        const clock = new THREE.Clock();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createMagicCircle();
            createParticles();

            camera.position.z = 15;

            renderer.domElement.addEventListener('click', onCircleClick);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createMagicCircle() {
            magicCircle = new THREE.Group();

            // Hovedcirkel og koncentriske cirkler
            for (let i = 0; i <= 3; i++) {
                const circleGeometry = new THREE.RingGeometry(5 - i * 0.5, 5 - i * 0.5 + 0.1, 64);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xD0D0D0, 
                    transparent: true, 
                    opacity: 0.9 - i * 0.1, 
                    side: THREE.DoubleSide,
                });
                const circle = new THREE.Mesh(circleGeometry, material);
                magicCircle.add(circle);
            }

            // Symboler med tentakler
            const symbolShapes = [
                createCircleShape(),
                createSquareShape(),
                createHeartShape(),
                createTriangleShape()
            ];

            for (let i = 0; i < 4; i++) {
                const symbolGroup = new THREE.Group();
                
                const symbolGeometry = new THREE.ShapeGeometry(symbolShapes[i]);
                const symbolMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xD0D0D0, 
                    transparent: true, 
                    opacity: 0.9,
                });
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.scale.setScalar(0.3);
                symbolGroup.add(symbol);

                // Tilføj tentakler til symbolet
                const tentacleMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xD0D0D0, 
                    transparent: true, 
                    opacity: 0.7,
                });

                for (let j = 0; j < 8; j++) {
                    const tentacle = createTentacle(tentacleMaterial, 150);
                    symbolGroup.add(tentacle);
                }

                const angle = (i / 4) * Math.PI * 2;
                const radius = 5;
                symbolGroup.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                
                if (i === 2) {  // Rotér hjertet, så det vender rigtigt
                    symbolGroup.rotation.z = Math.PI;
                }

                magicCircle.add(symbolGroup);
            }

            scene.add(magicCircle);
        }

        function createTentacle(material, segments) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = (Math.random() * 0.2 - 0.1) + Math.sin(t * Math.PI * 2) * t * 3;
                const y = (Math.random() * 0.2 - 0.1) + Math.cos(t * Math.PI * 2) * t * 3;
                const z = (Math.random() * 0.2 - 0.1) + (Math.random() - 0.5) * t * 2;
                points.push(new THREE.Vector3(x, y, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(200));
            return new THREE.Line(geometry, material);
        }

        function createCircleShape() {
            const shape = new THREE.Shape();
            shape.absarc(0, 0, 1, 0, Math.PI * 2, false);
            return shape;
        }

        function createSquareShape() {
            const shape = new THREE.Shape();
            shape.moveTo(-1, -1);
            shape.lineTo(1, -1);
            shape.lineTo(1, 1);
            shape.lineTo(-1, 1);
            shape.lineTo(-1, -1);
            return shape;
        }

        function createHeartShape() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1);
            shape.bezierCurveTo(0.5, 1.5, 1.4, 1, 1.4, 0.25);
            shape.bezierCurveTo(1.4, -0.25, 0.75, -0.75, 0, -1.4);
            shape.bezierCurveTo(-0.75, -0.75, -1.4, -0.25, -1.4, 0.25);
            shape.bezierCurveTo(-1.4, 1, -0.5, 1.5, 0, 1);
            return shape;
        }

        function createTriangleShape() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1);
            shape.lineTo(-1, -1);
            shape.lineTo(1, -1);
            shape.lineTo(0, 1);
            return shape;
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xD0D0D0,
                size: 0.03,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < 2000; i++) {
                const theta = THREE.MathUtils.randFloatSpread(360); 
                const phi = THREE.MathUtils.randFloatSpread(360);
                const r = 7 + Math.random() * 8;

                const x = r * Math.sin(theta) * Math.cos(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(theta);

                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Animate main circle and concentric circles
            magicCircle.rotation.z += 0.001;
            magicCircle.rotation.y = Math.sin(time * 0.2) * 0.05;
            magicCircle.rotation.x = Math.cos(time * 0.3) * 0.05;

            // Animate symbols and tentacles
            magicCircle.children.forEach((symbolGroup, index) => {
                if (index > 3) {  // Skip main circle and concentric circles
                    symbolGroup.rotation.z += 0.005 * (index % 2 ? 1 : -1);
                    symbolGroup.children.forEach((child, childIndex) => {
                        if (childIndex > 0) {  // Skip symbol, animate only tentacles
                            const positions = child.geometry.attributes.position.array;
                            for (let i = 0; i < positions.length; i += 3) {
                                const t = i / positions.length;
                                const waveX = Math.sin(time * 2 + index + t * 10) * 0.1;
                                const waveY = Math.cos(time * 1.5 + index + t * 8) * 0.1;
                                const waveZ = Math.sin(time * 1.8 + index + t * 9) * 0.1;

                                positions[i] += waveX * t;
                                positions[i+1] += waveY * t;
                                positions[i+2] += waveZ * t;

                                // Pull back to original shape
                                positions[i] *= 0.99;
                                positions[i+1] *= 0.99;
                                positions[i+2] *= 0.99;
                            }
                            child.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                }
            });

            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                
                const r = Math.sqrt(x * x + y * y + z * z);
                const theta = Math.atan2(y, x) + 0.0001 * r;
                const phi = Math.acos(z / r) + 0.0001 * r;
                
                positions[i] = r * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = r * Math.cos(phi);
            }
            particles.geometry.attributes.position.needsUpdate = true;

            if (isActivated) {
                particles.material.opacity = 0.8 + Math.sin(time * 2) * 0.2;
                magicCircle.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
            } else {
                magicCircle.scale.setScalar(1);
            }

            renderer.render(scene, camera);
        }

        function onCircleClick() {
            isActivated = !isActivated;
            if (isActivated) {
                activateMagicCircle();
            } else {
                deactivateMagicCircle();
            }

            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            }
        }

        function activateMagicCircle() {
            magicCircle.traverse(child => {
                if (child.material) {
                    child.material.color.setHex(0xFFFFFF);
                    child.material.opacity = Math.min(child.material.opacity + 0.2, 1);
                }
            });
            particles.material.color.setHex(0xFFFFFF);
        }

        function deactivateMagicCircle() {
            magicCircle.traverse((child, index) => {
                if (child.material) {
                    child.material.color.setHex(0xD0D0D0);
                    child.material.opacity = Math.max(0.9 - index * 0.1, 0.6);
                }
            });
            particles.material.color.setHex(0xD0D0D0);
            particles.material.opacity = 0.8;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
